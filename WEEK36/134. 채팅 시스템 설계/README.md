## 1. 서비스 목적 구체화하기

채팅 시스템도 모두 같은 채팅 시스템이 아니라 서비스 목적에 따라 달라짐

- 1 대 1 채팅에 중점을 둔 앱: 위챗, 왓츠앱
- 그룹채팅에 중점을 둔 앱: 슬랙
- 대규모 그룹 소통과 응답지연이 낮아야하는 음성채팅: 디스코드

### 책에 나와있는 목적

- 1대1 채팅과 그룹 채팅 모두 지원해야함
- 모바일 앱과 웹 앱 모두 지원해야함
- DAU는 5000만명으로 한정
- 그룹 채팅은 최대 100명의 인원이 참여할 수 있다고 가정함
- 중요 기능으로는 슬랙, 디스코드처럼 접속 상태 표시를 지원해야함
- 메시지 기능은 100,000자 제한
- 당장 메시지 암호화는 필요없지만, 추후 논의 예정
- 채팅 이력은 영원히 보관할 수 있어야함
- 푸시 알림을 지원해야함
- 하나의 계정으로 여러 단말에 동시 접속을 지원해야함

## 2. 개략적인 설계안 제시

채팅서비스는 기본적으로 아래 기능을 제공해야함

- 클라이언트로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아니라면 접속할 때까지 메시지 보관

채팅에 필요한 통신 프로토콜을 면접관과 이야기해야함

- HTTP
    - keep-alive 헤더를 사용하면 클라이언트-서버 사이의 통신이 유지될 수 있음
        
        + 3-way handshake 횟수를 줄일 수 있게 되어짐
        
        → 초기 채팅 시스템은 보통 HTTP를 사용함
        (페이스북, 카카오톡, …)
        
    - 이후 폴링, 롤 폴링, 웹소켓 기법을 사용하도록 발전해왔음
    기법들은 이전에 발표한 내용이므로 생략함 (https://hello70825.tistory.com/599)
    → 책에서는 웹소켓을 사용하기로 결정함

### [1] 무상태, 상태 유지, 제3자 서비스로 나누기

![image](https://github.com/user-attachments/assets/35548cfc-2b5d-42fd-a35b-cbb447284d7d)

- 세 종류로 나누는 이유
    - 상태 유지: 클라이언트와 채팅 서버가 네트워크 연결을 유지해야하는 채팅 서비스뿐임
    - 제3자 서비스(알람): 알림은 앱이 꺼져있어도 알림을 사용자에게 보낼 수 있어야함
    - 무상태: 굳이 특별한 이유가 없으면 연결 유지가 필요없는 무상태로 관리함
- 동시접속자가 백만명으로 가정하고, 한명 접속당 10K의 서버 메모리가 필요하다고 가정함
    - 10GB의 단일 메모리가 준비되어 있으면 모든 연결을 처리할 수 있음
    - 하지만 하나의 서버로 처리하면 SPOF가 되어버림

### [2] 나머지 시스템 설계 하기

![image](https://github.com/user-attachments/assets/e9bfc6ad-9d79-4739-8ff7-58e302b56e14)

- 네트워크 연결을 유지해야하는 채팅 시스템은 크게 2가지 기능으로 나눌 수 있음
    - `채팅` 과 `사용자 접속 상태 확인`
- 데이터 저장소에 대한 선택 및 설계도 생각해야함
    - 정형화된 데이터는 관계형 데이터베이스에 보관함
        - 사용자 프로파일, 앱 설정, 친구 목록, …
    - 채팅 데이터는 키-값 저장소를 추천함
        - 채팅 이력은 하루에 수백억개씩 저장되는 데이터지만, 오래된 데이터는 조회 빈도수가 점점 떨어짐
        - 사용자는 최근 채팅 이력을 자주보고, 검색이나 답장 기능을 통해 특정 메시지로 점프하는 일도 있음
        - 1대1 채팅은 읽기/쓰기 비율이 대략 1대1임
    - 키-값 저장소가 좋은 이유
        - 수평적 규모확장이 쉬움
        - 데이터 접근 지연시간이 낮음
            - RDB는 데이터가 많아질수록 JOIN, 정규화로 인해 데이터를 조회하면서 다수의 디스크 랜덤 I/O으로 인해 비용이 커지는데, 키-값은 키만 조회하면 값이 뭉텅이로 저장되어 있어서 단일 키로 조회 가능
        - ex. 페이스북 - HBase (하둡 위에서 쓰이는 데이터베이스), 디스코드 - Cassandra
    - 데이터 저장시 메시지 ID는 고유해야함
        - RDB면 auto_increment가 대안이 될 수 있음 (마스터 서버 1개일 때)
        - 하지만 NoSQL은 그런거 없어서 스노플레이크와 같은 유일 ID 생성기 설계를 사용해야함
        - 또는 데이터를 저장하는 그룹 안에서만 유일성이 인정되는 지역적 순서 번호 생성기라는 방법도 있음

## 3. 상세 설계하기

### 채팅 서버 탐색 설계

![image](https://github.com/user-attachments/assets/ad8c524b-9a5c-49e7-8034-1b0e529256d9)

클라이언트에게 적합한 채팅 서버를 추천함

- 기준: 클라이언트의 지정학적 위치, 서버의 용량, …
- 사용 기술: 보통 아파치 주키퍼를 사용하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라줌

### 메시지 흐름 설계

![image](https://github.com/user-attachments/assets/1b72c1b1-b810-477d-a7f4-ed6fd36239c2)

1. 사용자 A가 채팅 서버 1로 이동
2. 채팅 서버 1은 ID 생성기를 사용해 메시지 ID 결정
3. 채팅 서버 1은 메시지를 메시지 동기화 큐로 전송
4. 메시지를 키-값 저장소에 보관
5. 사용자 B가 접속중이면 채팅 서버 2로 보내고, 아니라면 푸시알림 서버로 보냄
(이후 접속하면 다시 채팅 서버2로 보냄)
6. 사용자 B와 채팅 서버 2는 웹소켓 연결이 되어 있으므로 채팅 서버 2는 메시지를 사용자 B에게 전송함

### 메시지 동기화

하나의 아이디로 여러 단말에 접속해 채팅을 할 수도 있음

![image](https://github.com/user-attachments/assets/b817cb84-474a-48e3-a136-fde8708330b7)

사용자 A는 전화로 메시지를 봤다가, 랩톱에서 다시 메시지를 볼 수도 있음

이때 cur_max_message_id를 통해 특정 단말에서 관측된 가장 최신 메시지 ID를 추적함

이러면 서버는 cur_max_message_id를 통해 새 메시지를 가져오는 동기화 작업을 쉽게 구현할 수 있음

### 소규모 그룹 채팅방 흐름 설계

![image](https://github.com/user-attachments/assets/2384f402-56a1-4c86-88b2-10ca3083834d)

각자에게 할당된 메시지 동기화 큐를 확인하게 함

- 자기 큐만 보면 되니까 동기화 플로우가 단순해짐
- 소규모이면 메시지를 복사해서 큐에 넣는 작업의 비용이 낮음
- ex. 위챗은 최대 500명으로 제한해서 사용중임

![image](https://github.com/user-attachments/assets/81a96a65-3174-4bcb-93a1-097046a02962)

채팅방은 여러명에서 말하는 것이니 수신자 입장에서의 메시지 동기화 큐는 위 사진과 같다고 할 수 있음
