# 122. 쿠버네티스 오버뷰

발표자: 이상재
발표 날짜: 2024년 3월 2일

## 컨테이너 오케스트레이션 (쿠버네티스는 왜 나왔을까)

- 구글은 2000년대 후반부터 수십만개의 컨테이너를 운용하는 과정에서 생기는 **관리의 어려움을 해결**하고자 사내 시스템을 개발함

- 2014년 Google에서 사용하던 컨테이너 오케스트레이션 시스템 보그(Borg)를 오픈 소스 소프트웨어 쿠버네티스
  공개

## 쿠버네티스란?

> 쿠버네티스는 컨테이너화된 **워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼**이다. 쿠버네티스는 **선언적 구성과 자동화**를 모두 용이하게 해준다. 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다. **쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용**할 수 있다. - 공식문서 -

## 쿠버네티스의 구조

- **중앙(Master)에 API 서버와 상태 저장소**를 두고 **각 서버(Node) 의 에이전트(kubelet)**과 통신하는 단순한 구조
- Master를 쿠버네티스에서는 **Control Plane**이라고 함
- 모든 명령은 **마스터의 API 서버를 호출**하고, **노드는 마스터와 통신하면서 필요한 작업 수행**
- **Kubectl** 이라는 Client 도구로 API 서버 접근 가능

## Desired State

- 관리자가 바라는 환경 (구체적으로 웹서버 몇개 띄울건지, 몇번 포트로 띄울건지)
- **현재 상태(current state) 를 모니터링**하면서 관리자가 설정한 **원하는 상태(desired state)를 유지하는 방향으로 동작**

**쿠버네티스의 핵심은 상태이며 쿠버네티스를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지를 알아야 함**

## 쿠버네티스 객체

- 쿠버네티스 객체는 쿠버네티스 시스템에서 **영구적인 엔티티들**
- 엔티티들이 가지고 있는 정보
  - 어떤 컨테이너화된 어플리케이션들이 실행되고 있는지 (그리고 어떤 노드에 있는지)
  - 그 어플리케이션들이 **사용가능한 자원들은 어떤것**인지
  - 어플리케이션이 어떻게 작동할 것이고 어떻게 재시작 될것이고 어떻게 변경될것이고 실행 중 실패하면 어떻게 될것인지
- 쿠버네티스 시스템은 쿠버네티스 객체가 만들어질때부터 객체가 지속적으로 살아있을수 있도록 만듬
- **쿠버네티스 객체를 만들고, 수정하고, 지우기 위해서는 쿠버네티스에서 제공하는 API를 사용**해야함
- 대표적으로 api를 사용할 수 있는 방법은 CLI인 kubectl
- 모든 쿠버네티스 객체는 객체의 설정을 다루기위해 두가지 필드를 가지고 있다.

### spec

쿠버네티스 객**체를 생성할때 설정하는 값으로 자원이 어떤 특징을 가질지를 서술**한다
이를 desired state라 한다.

### status

**쿠버네티스 시스템과 구성 요소들이 해당 객체의 상태를 제공하고 변경하는데 그에 대한 현재 상태는 status에 기록**된다.
쿠버네티스의 control plane은 객체들의 실제 상태가 desired state와 일치하도록 지속적으로 능동적으로 관리한다.

## 쿠버네티스 객체 관리 방법 - 명령형

- 개발자는 **kubectl의 명령과 인자를 통해 객체를 조작**
- **단순한 명령(한줄짜리)이나 처음 객체를 시작할때 권장되는 방법**
  - kubectl create deployment nginx --image nginx

### 장점

- 명령들이 한 줄로 표현된다.
- 객체에 조작을 가해 변화를 주는데 한큐에 끝난다.

### 단점

- 명령을 통한 **변화에 통합과정이 없다.** (CI에서의 문제를 생각하면 될듯)
  - 공통으로 작업하는 쿠버네티스 클러스터에 한 팀원이 명령형 방식으로 객체를 생성
  - 다른 팀원들이 해당 객체 생성에 대해 체크하기 어려움
    - 객체를 잘 생성했는지
    - 어떤 객체를 생성했는지
- 어떤 변경이 언제 일어났는지 누가 이 명령을 실행했는지 **로그가 안남음**
  - 공통으로 작업하는 쿠버네티스 클러스터에 한 팀원이 명령형 방식으로 객체를 생성
  - 해당 객체가 생성된 것을 늦게 다른 팀원이 확인하지만 언제부터 누가 어떻게 해당 객체를 생성했는지 확인 못함
- **객체의 상태에 대한 히스토리가 전혀 안남음**
  - 어떤 객체가 있었는지 어떤 객체를 띄울건지에 대한 기록이 없음
- **명령어를 사용할때마다 필요한 옵션, 설정을 전부 지정해야함**
  - 위에서 언급한 metadata, spec과 같은 설정들을 일일이 명령에 쳐야댐
    - 매우 노가다 & 일관적이지 않음 = **반드시 실수한다**

## 쿠버네티스 객체 관리 방법 - 선언형 오브젝트 구성

- 선언형에서는 개발자가 파일을 통해 명령어로 객체에 대해 조작하지 않음
- 개별 객체에 대한 생성, 수정, 삭제 작업은 kubect이 자동으로 알아서 감지하고 수행
  - kubectl diff -f configs/
  - kubectl apply -f configs/

### 장점

- 쿠버네티스 클러스터에서 **직접 객체의 설정을 변경한다면 변경 사항은 해당 파드가 존재하는 동안 유지**됨
- 선언형 방식에서는 **실시간으로 적용된 변경 사항이 실제 객체에 바로 반영되고 유지**되는 이점이 있음
- 선언형 구성을 사용하면, 여러 구성 파일들이 포함된 디렉토리를 한 번에 처리할 수 있음
  - 디렉토리 내의 **모든 구성 파일에 대해 적절한 작업(생성, 수정, 삭제)을 자동으로 감지하고 적용**. 복잡한 구성을 갖는 애플리케이션을 관리할 때 특히 유용함

### 단점

- YAML 파일에 문법 오류가 있거나, 예상치 못한 리소스 간의 충돌이 발생하는 경우, 이러한 문제를 진단하고 해결하기 위해서는 파일의 내용을 개별적으로 분석해야함
- 명령형 방식에서는 실시간으로 각 명령의 결과를 볼 수 있어, 문제가 발생했을 때 바로 대응이 가능
  - 선언형 구성에서는 기존 상태와 새로운 구성 사이의 차이(diff)를 기반으로 부분 업데이트를 수행하게되는데. 이 과정에서 병합과 패치 연산이 필요함
- 여러 개발자가 동시에 같은 쿠버네티스 객체의 다른 부분을 수정하는 경우, **변경사항들을 합치는 과정, 통합 과정이 필요**함

## 쿠버네티스 객체의 이름과 ID

- 클러스터안에 있는 **모든 객체는 같은 종류의 객체 사이에서 유일한 이름**을 가지고 있음
  - 예를 들어 Pod에서 okestro 라는 이름의 객체가 있다면 또 다른 okestro 라는 이름의 Pod 객체는 불가능하지만Deployment는 가능하다.
  - 이는 namespace 때문인데 이는 밑에서..
- name은 클라이언트가 제공하는 문자열로 쿠버네티스에서 사용하는 URL에도 포함됨
  - ex) /api/v1/pods/{name}
- **위 URL에서 알 수 있듯이 같은 종류의 Object는 같은 이름을 가지게 된다면 같은 URL가지게 되어
  특정할 수가 없음**
    - 어떤 name을 가진 객체를 지우고 이와 동일한 name을 가진 객체를 만드는 것은 가능

### 주의할점

- **API 버전이 다르다고 name이 같은 객체가 생길 수 없음 URL은 다르더라도 아무튼 안됨**
- 또한 위에서 볼 수 있듯이 URL형태이고 서버의 서브도메인 형태이기에 **URL에서 따르는 기본적인 규칙을 지켜야한다.**
  - 영문 소문자, ‘-’만 포함
  - 영문 숫자로 시작하고 영문,숫자로 끝나야한다.

## UID

- **오브젝트를 중복없이 식별하기 위해 쿠버네티스 시스템에서 부여하는 유일한 문자열**
  - 오브젝트 name으로 다 되지 않나?
    - **name은 이전에 동일한 name을 지녔던 객체가 내려간다면 동일한 name을 다시 가질 수 잇음**
- 같은 name을 지닌 두 객체를 기록에서 어떻게 구분할것인가?
  - **쿠버네티스 시스템이 구동되는 동안 유일한 식별자인 UID를 주자!**

## 레이블

- 레이블은 **파드와 같은 오브젝트에 첨부된 키와 값**
- 레이블은 **오브젝트의 특성을 식별하는데 사용되어 사용자에게 중요하지만 쿠버네티스 시스템에게는 직접적인 의미는 없음**
- **레이블로 오브젝트의 하위 집합을 선택하고 구성하는데 사용가능**
- 즉, 사용자가 어떤 오브젝트 혹은 오브젝트들의 집합을 검색하고 싶을때 사용할 수 있는 사용자가 정의한 특성
- 왜 사용했는지?
  - 레이블을 이용하면 자원들을 분류할 수 있고 서비스 배포나 배치에서는 관리를 위해 쿠버네티스 객체들을 매핑할 필요가 있다,
  - 또한 클라이언트에서 분산적으로 매핑을 관리한다기보다 쿠버네티스 시스템에서 직접 매핑을 관리하는게 더 좋다.

### 사용 예시

```java
"release" : "stable", "release" : "canary"
"environment" : "dev", "environment" : "qa", "environment" : "production"
"tier" : "frontend", "tier" : "backend", "tier" : "cache"
"partition" : "customerA", "partition" : "customerB"
"track" : "daily", "track" : "weekly"
```

## 레이블 셀렉터

- **레이블 셀렉터를 통해 클라이언트(kubectl과 같은)는 오브젝트를 식별**할 수 있다.
- 레이블 셀렉터는 두가지 종류가 있다.

### 일치성 기준

- 레이블의 키와 값을 일치 또는 불일치를 기준으로 필터링한다.
- 여러개의 일치성 기준을 지정했다면 모두 만족하는 결과를 필터링한다.
- = , == , ≠ 모두 가능

예시)

```java
environment = production
tier != frontend
```

### 집합성 기준

- in, notin, exists 3개의 연산자를 지원한다.

```java
environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
```

일치성 기준과 집합성 기준 둘다 혼용하여 사용할 수 있다.

## 네임스페이스

- 네임 스페이스는 단일 클러스터 내에서 리소스 그룹 격리 매커니즘을 제공
- **리소스의 이름은** **네임 스페이스 내에서 유일해야 하며 네임스페이스 간에서 유일할 필요는 없음**
- 네임스페이스가 왜 좋은데?
  - 한 물리적인 서버에서 다른 어플리케이션이 돌때 서로 영향을 최소화
    - 이 개념은 **프로젝트 단위에서도 적용**가능
  - 네임스페이스에 대한 권한으로 서버 사용자나 그룹에게 부여 (세밀한 보안)
  - 물리적인 자원을 관리할때 네임스페이스로 할당 (효율적인 물리자원 관리)
    - 이때 **네임스페이스에게 주어지는 클러스터의 물리적 자원(가상화된 자원도 될수있음)을 resource quotas** 라고함

## 어노테이션

- **어노테이션을 사용하여 비식별 (유일하지 않은) 메타데이터를 쿠버네티스 객체에 첨부**할 수 있다.
- 클라이언트(kubectl, 라이브러리를 사용한 어떤 프로그램)은 이 **메타데이터를 검색 가능**
- 레이블 vs 어노테이션
  - **레이블의 목적은 쿠버네티스 객체를 식별**(구분)하고 원하는 조건에 만족하는 애들은 찾기위해
  - **어노테이션의 목적은 디버깅, 서드파티에 필요한 정보 제공, 로깅, 기타 오브젝트에 관한 부가적인 정보를 추가**하기 위해 만들어짐

## 노드

- 쿠버네티스는 **컨테이너를 파드내에 배치하고 노드 에서 실행**함으로 워크로드를 구동한다.
- **노드는 클러스터에 따라 가상 또는 물리적 머신**일 수 있다.
- 각 노드는 컨트롤 플레인에 의해 관리되며 파드를 실행하는 데 필요한 서비스를 포함한다.
- 클러스터에는 여러 개의 노드가 있으며, 학습 또는 리소스가 제한되는 환경에서는 하나만 있을 수도 있다.

### 노드의 구성요소

- Kubelet
  - 노드에서 실행되는 에이전트
  - 컨트롤 플레인이 Pod를 노드에 배치할때 해당 Pod가 정상적으로 작동하도록 관리
- Container Runtime
  - Pod내부에서 컨테이너를 실행하는 소프트웨어
- Kube-Proxy
  - 네트워크 프록시 및 로드 밸런서 역할을 하는 구성 요소
  - 각 노드에 있어서 서비스(Service)의 네트워크 규칙을 유지 관리하고, 네트워크 통신을 파드로 전달하는 역할

## Pod

- Pod는 쿠버네티스에서 **생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위**
- Pod는 **하나 이상의 컨테이너 그룹**
- 왜 컨테이너들을 그룹으로 묶었을까?
  - **스토리지와 네트워크 설정을 공유해야 하는 컨테이너**들이 있기 때문에
  - **같은 라이프사이클을 가져야하는 컨테이너**들이 있기때문에
  - **같은 논리적 단위로 묶여 관리하기 편할 수 있는 컨테이너**들이 있기때문에

## Reference

[https://kubernetes.io/ko/docs/home/](https://kubernetes.io/ko/docs/home/)
