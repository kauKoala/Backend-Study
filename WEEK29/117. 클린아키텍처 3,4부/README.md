## 3부. 설계 원칙

설계원칙은 객체지향 SOLID에 대한 내용이 담겨져 있음

그래서 간단하게 설명하고 넘어감

### [1] SRP (단일 책임 원칙)

- 우리가 알던 SRP: 함수는 단 하나의 일만 해야한다
- 책에 나오는 SRP: 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다

우리가 알던 SRP는 저수준에서 사용되는 원칙이고, 최근에서야 언급되고 있는 내용임

하지만 책에 나오는 SRP는 역사적으로 이런 내용이 기술되었다함

### [2] OCP (개방 폐쇄 원칙)

- 확장에는 열려있고, 변경에는 닫혀있어야한다
(개체의 행위는 확장할 수 있지만, 개체를 변경해서는 안된다)

인터페이스 A의 구현체인 x, y가 있다면 x의 코드가 수정될 때, y의 코드가 수정되면 안된다는 뜻

= 보통 인터페이스 없이 구현한다면 x, y가 한 클래스에 코딩되어 있으니 이런 문제가 발생함

### [3] LSP (리스코프 치환 원칙)

- 부모 객체와 자식 객체가 있을 때, 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전이 대체할 수 있다
(책 내용은 어렵게 설명되어 있음)

아래 상황이 벌어지면 안된다는 일

[예시]

다양한 택시 파견 서비스(우버, 카카오T, ..)를 통합하는 서비스를 만드는 상황

우버는 URI에 아래값을 사용함

- pickUpAddress
- pickUpTime
- destination

이때 우버가 아닌 카카오 T에서는 우버랑 다르게 축약어를 사용함

- pickUpAddress
- pickUpTime
- dest

그래서 코딩할 때 카카오로 인해 호출하는 상위 클래스에서 if문을 추가해 destination으로 요청이 들어오면 dest로 바꿔주는 작업을 진행해야함 (혹은 반대로)

### [4] ISP (인터페이스 분리 원칙)

인사시스템에 User 1, User 2는 서로 다른 기능을 사용하는데, 코딩상으로는 하나의 인터페이스에 모든게 구현되어 있음

이러면 잘못된 것이니 서로 다른 기능은 인터페이스로 분리하자는 뜻

### [5] DIP (의존성 역전 원칙)

의존성이 추상에 의존하며, 구체에는 의존하지 않는 원칙

![image](https://github.com/user-attachments/assets/89afff0d-5080-4d61-b985-3ecec81a0118)

책에서는 이게 제일 중요한 원칙이라고 나와있음

## 4부. 컴포넌트 원칙

### [1] 컴포넌트

옛날 컴퓨터 역사에 대한 이야기

- 옛날에는 프로그램을 어느 메모리 위치에 로드할지 결정되면 이후 재배치가 불가능 했음
- 중간에 코딩하다가 다른 코드가 있는 메모리 영역을 넘어서는 수준이라면 세그먼트를 사용해 코드를 분리했음
- 이 과정에서 운영체제 링크, 로드가 발전하고, 링크 시간이 초단위로 줄어들고, .jar 파일도 나오게 되었음

### [2] 컴포넌트 응집도

- REP (재사용/릴리즈 등가 원칙)

gradle, maven 같은 도구가 유명해진 이유는 소프트웨어 재사용 때문임

이때 릴리즈 절차가 없을 경우, 소프트웨어가 수정 됐을 때 호환이 되는지 안되는지도 모르고, 릴리즈의 추적 관리도 어려워짐

- CCP (공통 폐쇄 원칙)

동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라 (SRP, OCP와 유사함)

소프트웨어는 재사용성도 중요하지만, 유지보수성이 매우 중요하기 때문에 변경이 여러 컴포넌트에 분산되어 발생하기보다는 하나의 컴포넌트에서만 변경이 일어나고 배포해야 릴리즈 > 재검증 > 배포 프로세스 비용이 낮아짐

- CRP (공통 재사용 원칙)

컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라 (ISP와 유사함)

사용자가 사용하지도 않는 컴포넌트로 인해 업데이트해야한다면 개발자는 의미없는 컴포넌트로 인해 리소스가 많이 사용된다는 것을 인지하기

### [3] 컴포넌트 결합

- ADP (의존성 비순환 원칙)

컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안된다

[예시 상황] 전 날에 무언가를 작동하게 만들고 퇴근했는데, 다음날 전혀 돌아가지 않을 때. 이때 이유는 다른 누군가가 내가 의존하고 있던 무엇가를 수정해서임. 그래서 나도 그 의존하고 있는 코드를 돌아가게 수정하다가 많은 개발자가 한 파일을 수정함

이때의 해결법은 주 단위 빌드와 의존성 비순환 원칙이 있음

- 주 단위 빌드는 모든 개발자가 평일의 4일동안 서로 신경쓰지 않다가 배포날에 모든 업보를 받는 것
- 순환 의존성 제거는 특정 컴포넌트를 수정하면, 그 컴포넌트를 의존하는 다른 팀은 이전 버전 릴리즈를 사용하는 것임. 이후 다른 팀에서 최신 버전 컴포턴트를 사용할지 말지 결정하여 의존성을 끊음

- SDP (안정된 의존성 법칙)

안정성의 방향으로 더 안정된 쪽에 의존하라

= 변경이 쉽지 않은 컴포넌트가 변경이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안된다

(이러면 변경이 쉬운 컴포넌트도 결국 변경이 어려워짐)

- SAP (안정된 추상화 원칙)

컴포넌트는 안정된 정도만큼만 추상화되어야 한다

(안정된 컴포넌트 = 추상 컴포넌트, 불안정한 컴포넌트 = 구체 컴포넌트, DIP랑 비슷함)
