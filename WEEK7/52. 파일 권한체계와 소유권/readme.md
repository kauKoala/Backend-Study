```
$ ls -l
total 0
-rwxr-xr-x 1 brorica brorica 0 Jan 30 09:05 file1
-rwxr--r-- 1 brorica brorica 0 Jan 30 09:05 file2
-rw-r--r-- 1 brorica brorica 0 Jan 30 09:05 file3
-rw-r--r-- 1 brorica brorica 0 Jan 30 09:05 file4
```

## ![Untitled](https://github.com/kauKoala/Backend-Study/assets/7845568/97dfa27d-d0c2-4d8f-9b30-6c5d57fc1ff7)

## 소유권 유형

1. user: 파일을 소유한 개인
2. group: 파일을 소유한 개인이 속한 그룹
3. other: 말 그대로 제3자

## 권한 유형

1. read = **4**
2. write = **2**
3. execute = **1**

execute에서 디렉토리와 파일의 차이점이 발생하는데

파일이 말 그대로 실행에 대한 권한이라면

디렉토리는 cd 명령어를 통해 디렉토리 내부까지 접근할 수 있는지를 나타낸다.

예를 들자면

400(r—): ls 등의 명령어를 통해서 확인 가능하지만 cd로 내부 접근 **X**

500(r-x): ls 명령어로 확인 가능 + cd로 내부 접근 **O**

### 기본 권한

파일: 666(rw-rw-rw-)

디렉토리: 777(rwxrwxrwx)

## 특수 비트

1. SetUID = **4000**, **s**
2. SetGID = **2000**, **g**
3. Sticky = **1000**, **t**

일반 권한과 같이 4, 2, 1로 분류되지만 하나의 비트만 설정할 수 있다.

이 비트는 최상단에 위치해 **천**의차리 숫자를 담당한다.

ex) rwxrw-rw- 파일에 SetUID를 설정하면 **744**가 아닌 **4744**가 된다.

### SetUID, SetGID

각각 파일의 소유자, 그룹 사용자 권한으로 실행하게 함

즉, 내가 일반 사용자라도 소유자나 그룹 사용자인 것처럼 행동할 수 있다.

ex) 리눅스 패스워드 정보는 root가 관리하지만, 모든 사용자는 passwd 명령어를 통해 자기 계정의 비밀번호를 바꿀 수 있다. 이게 가능한 것은 passwd에 SetUID가 적용됐기 때문이다.

이런 점을 노려 시스템 콜 등을 사용한 권한 상승 취약점 공격도 있어서 신중해야 한다.

### sticky bit

디렉토리의 사용자 권한 제어에 사용.

디렉토리 소유자와 자신만을 제외하고 자신이 생성한 파일에 대해 수정, 삭제 권한을 가지고 싶은 경우에 사용한다.

게시판을 예로 들자면 내가 쓴 글은 나와 관리자만 지우거나 수정할 수 있다.

## 대문자? 소문자?

**일종의 경고 메시지**라 보면 된다.

SetUID 또는 SetGID가 지정됐지만 실행 권한이 없는 경우, **s**가 아닌 **S**로 표시된다.

sticky bit도 마찬가지로 실행 권한이 없는 경우, **t**가 아닌 **T**로 표시된다.

## umask

디렉토리 내에 파일이 생성될 때 권한을 자동으로 설정

chmod 처럼 권한 초기값을 부여하는게 아닌, 값을 빼는 방식이다.

ex) 파일 기준 umask 022를 적용하면 해당 디렉토리에서 생성되는 파일 권한은 644(rw-r—r—)이다.

## 심볼릭 링크, 하드 링크에서의 차이

심볼릭 링크는 원본 파일의 권한과 소유권을 따라간다. 심볼릭 링크된 파일의 소유권과 권한을 변경할 순 있지만, 실행하기 위해선 원본 파일을 실행하기 때문이다.

하드 링크의 경우 한 쪽이 바뀌면 다른 쪽도 바뀐다. 같은 inode를 공유하기 때문에 한 쪽에 변경 사항이 생기면 다른 쪽도 변경된다.