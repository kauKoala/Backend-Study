# 드라이빙 테이블



## 드라이빙 테이블이란?

DBMS가(옵티마이저) Join을 수행할때 여러 테이블에 존재하는 데이터들을 취합하기 위해서 접근하는 데이터의 순서를 정하는데 먼저 접근하는 테이블 즉, 데이터 탐색에 기준이 되는 테이블을 드라이빙(Driving Table)이라 하고 나중에 접근하는 테이블을 드리븐 테이블(Driven Table)이라고 한다.



다른 표현으로는 드라이빙 테이블을 Outer Table이라 하고 드리븐 테이블을 Inner Table이라 한다.



데이터의 크기가 많아질 수록 드라이빙 테이블은 중요해진다. 

일반적으로 MySQL에서 사용되는 NL(Nested Loop Join)을 예시로 들어서 설명해보겠다. (MySQL은 8.0.20 버전부터 Hash Join을 사용한다) 



NL Join의 경우 드라이빙 테이블에서 추출되는 데이터 건수만큼 드리븐 테이블을 반복해서 탐색한다.

만약 드라이빙 테이블이 매우 클 경우 그 만큼 드리븐 테이블의 데이터를 반복해서 탐색해야 하므로 SQL 성능에 큰 영향을 끼치게 된다.

따라서 힌트를 사용하여 드라이빙 테이블과 드리븐 테이블 선정에 대해 옵티마이저를 강제할 경우 해당 SQL에 대해 드라이빙 테이블의 데이터 수를 생각해야 한다.

만약 드리븐 테이블을 탐색할때 기준이 되는 칼럼이 (검색 조건에 사용되는 칼럼)이 인덱스가 아닐경우  쿼리 성능은 더욱 더  악화될 것이다. 



따라서 DBMS에서 SQL 성능을 최적화 하고자 하는 옵티마이저는 드라이빙 테이블을 선정할 때 테이블의 데이터 수, 인덱스 유무, 인덱스의 통계, SQL 힌트를 고려하여 정한다.

또한 옵티마이저는 드리븐 테이블의 데이터에 접근할때도 성능 향상을 위해 드리븐 테이블의 인덱스를 활용하는 실행 계획을 수립한다.  (드라이빙 테이블마다 동일 조건으로 반복해야 하므로 데이터가 커지면 굉장히 느려짐)



## 조인 버퍼(Join Buffer)



드리븐 테이블에 대한 데이터 검색시 NL Join 방식은 드리븐 테이블의 검색조건에 인덱스가 존재할 수록 효율이 증가한다. 하지만 드리븐 테이블에 인덱스가 항상 존재하는 경우는 아니며 만약 인덱스가 존재하지 않을 경우 드라이빙 테이블의 로우 수만큼 FULL TABLE SCAN을 드리븐 테이블에 해야한다. 



옵티마이저 자체적으로 드라이빙 테이블의 내용을(읽은 로우들을) 메모리에 캐시하고 해당 메모리를 드리븐 테이블과의 검색에 사용한다.

Join Buffer 방식은 메모리에 드라이빙 테이블 내용을 캐싱하기 때문에 드라이빙 테이블에 대한 잦은 Disk I/O를 줄일 수 있다.



하지만 모든 캐시 메모리가 그렇듯 캐시 사이즈에 대해 고민해봐야 하는데 너무 클 경우 DBMS에 할당된 메모리를 조인 버퍼가 대부분 사용할 수 도 있고 너무 적을 경우 잦은 Cache Miss로 줄이고자 했던 Disk  I/O를 줄일 수 없게 된다.



MySQL에서는 환경 변수로 'join_buffer_size'로 존재한다.

**Hash Join** 방식은 자체적으로 Join Buffer의 역할과 유사한 Hash Table을 사용하여 Join하는데 이때 Hash 알고리즘을 사용하여 Join한다.

**Oracle**에서는특정한 Join Buffer를 명시적으로 두지않고  **SGA (System Global Area)**라는 메모리 영역에 데이터 버퍼 캐시를 둬 Join 전반적인 Disk I/O를 줄인다.



### 주의해야 할 점

일반적으로 Join을 통해 데이터를 조회할때는 드라이빙 테이블의 결과를 조회하고 정렬한 후 드리븐 테이블을 조회한다.

따라서 정렬된 드라이빙 테이블과 드리븐 테이블을 Join하면 작업 결과 역시 드라이빙 테이블을 기준으로 정렬된 것을 확인할 수 있다.

하지만 Join Buffer가 사용되는 NL Join의 경우 드리븐 테이블의 결과를 조회하고 Join Buffer의 데이터를 조회하는데 

따라서 드라이빙 테이블의 데이터가 정렬되었다 하더라도 드리븐 테이블의 조회된 데이터가 기준이 되므로 결과의 정렬을 보장하지 못한다.

만약 Join 결과 자체의 정렬을 원한다면 별도의 Join 최종 결과에 대한 정렬을 해야한다.





