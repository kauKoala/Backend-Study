# 1. Lock이란?

**여러 사용자들이 동시에 같은 데이터에 접근할 때, 데이터의 무결성과 일관성을 보장하기 위해 사용하는 매커니즘**

**쉽게 말해, 데이터의 접근을 막기 위한 장치**

- 데이터베이스, 파일, 테이블, 열(column), 행(row) 등의 수준(Level)으로 Lock의 범위를 설정할 수 있음
    - 일반적으로 행(row) 수준의 Lock이 가장 많이 사용됨

# 2. Lock의 종류

## 공유 락('S'hared Lock)

**데이터를 변경하지 않는 읽기 명령에 주어지는 락 (= Read Lock)**

- 공유 락이 걸린 데이터는 읽기 O, 쓰기 X
- 여러 트랜잭션에 의해 동시에 읽힐 수 있음
    - 동시 읽기가 가능하므로 동시성 향상

## 배타 락(e'X'clusive Lock)

**데이터를 변경하는 쓰기 명령에 주어지는 락 (= Write Lock)**

- 배타 락이 걸린 데이터는 해당 락을 건 트랜잭션에 의해서만 읽고 쓰일 수 있음
    - 다른 어떤 트랜잭션도 해당 데이터에 접근 불가

그 외에도

데이터 수정을 위해 배타 락을 걸기 전 데드락을 방지하기 위한 **업데이트 락(Update Lock)**

사용자가 요청한 범위에 대해 락을 걸 수 있는지 빠르게 파악하기 위한 **내재 락(Intent Lock)**

등이 있음

# 3. Lock 전략

데이터 충돌을 처리하는 방법과 데이터 무결성을 보장하는 방식을 기준으로 아래의 두 가지로 나눌 수 있음

## 낙관적 락

**데이터 충돌이 드물 것으로 가정하고, 트랜잭션의 대부분 시간 동안 락을 걸지 않는 방식**

- 데이터에 버전 번호, 타임스탬프 등을 사용하는 방식으로 처리
    - 트랜잭션이 데이터를 업데이트 할 때, 버전 번호 혹은 타임스탬프가 처음 읽을 때의 값과 동일한지 확인

      → 동일하지 않다면 다른 트랜잭션이 데이터를 이미 변경했다는 뜻

      → 충돌이 발생했다고 간주

- Application Level의 Lock

- 동시성이 높지만, 충돌이 발생하면 재시도 혹은 충돌 해결 로직이 필요함
- 성능이 높지만, 충돌이 발생했을 때의 오버헤드가 있음

## 비관적 락

**데이터 충돌이 자주 발생할 것으로 가정하고, 트랜잭션 동안 관련 데이터에 락을 걸어 다른 트랜잭션의 접근을 차단하는 방식**

- 트랜잭션이 시작될 때, 공유 락(S) 혹은 배타 락(X)을 걸고 시작
- 데이터 충돌의 가능성이 높거나, 데이터의 무결성이 매우 중요한 상황에 적합
    - 계좌 잔액 변경 트랜잭션 등에 쓰임

- 동시성이 낮지만, 충돌을 미리 방지할 수 있음
- 락 관리와 데드락 방지를 위한 추가적인 오버헤드가 있음

**참고자료**

- [https://velog.io/@koo8624/Database-데이터베이스-락Lock의-종류와-역할](https://velog.io/@koo8624/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%9D%BDLock%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%97%AD%ED%95%A0)
- https://sabarada.tistory.com/121
- https://sabarada.tistory.com/175