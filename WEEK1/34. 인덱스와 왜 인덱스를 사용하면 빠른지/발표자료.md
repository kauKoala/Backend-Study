# 34. 인덱스와 왜 인덱스를 사용하면 빠른지?

## 인덱싱이란?

특정 정보를 빠르게 찾기 위한 자료 구조.

RDBMS, NOSQL 각각 인덱싱 자료구조가 있기 때문에 앞에 어떤 환경의 인덱싱인지 명시해야 한다.

면접 때 그냥 인덱싱이라 했다가 RDBMS 인지 NOSQL 환경에서 인덱싱인지 되물어봤음

## 왜 빠른가?

인덱싱 트리 내에서 노드의 대소 비교를 통해 원하는 노드로 이동을 한다.

매번 경우의 수가 반으로 줄어들어 logN 시간 복잡도를 보여준다.

만약, 인덱싱이 적용되지 않으면 선형 탐색을 하기 때문에 O(N) 시간 복잡도가 발생한다.

## 인덱스는 언제나 좋은 건가?

인덱싱이 많아지면 다음 문제들이 발생한다.

1. 데이터베이스 공간 차지
    1. 인덱스를 지정하면 거기에 맞는 인덱스 트리를 생성하게 된다.
    테이블 용량보다 더 커지는 문제가 발생할 수 있다.
2. 오버헤드 발생
    1. 삽입, 수정, 삭제시 인덱스 테이블을 재구한다. 이 작업은 cpu intensive 한 작업이라  오버헤드가 발생한다.
3. 쿼리 옵티마이저 오류
    1. 당연하지만, 너무 많은 인덱싱은 쿼리 옵티마이저가 최적화를 제대로 수행할 수 없게 한다.

검색 결과 한 테이블당 인덱스 개수는 3~4개로 제한한다.

만약, 여러 컬럼에 인덱싱을 해야한다면 정규화를 통해 테이블을 분산하는 것도 방법이다.

## 인덱스 종류

### 클러스터링 인덱스

지정된 컬럼에 맞춰 데이터를 물리적으로 재정렬한다.

테이블 당 하나의 클러스터링 인덱스만 적용할 수 있다.

PK 가 정해지면 클러스터링 인덱스가 실행되고, PK가 없다면 Unique + Not NULL 인 컬럼을 기준으로 수행한다.

정적인 테이블에 유리하다.

데이터가 변동될 때마다 재정렬을 수행하진 않지만. 데이터가 많으면 재배치 비용이 크다.

### 논 클러스터링 인덱스

데이터를 물리적으로 재배치 X

**인덱스 키와 물리적 주소를 매핑**한 구조를 생성한다.

ex) 사전의 찾아보기를 예로 들면
클러스터링 인덱스: 가나다 순으로 **단어들을 모아놓음**
논 클러스터링 인덱스: 단어들이 **어느 페이지에 있는지** 명시

하나의 테이블에 여러 개의 논 클러스터링 인덱스를 생성할 수 있다.
검색 조건이 다양할 경우, 조회 성능을 높일 수 있다.

**그렇다면 논 클러스터링 인덱스를 많이 걸면 좋은거 아닌가?**

- 인덱스 구조를 만들기 때문에 저장공간 부담이 증가한다.
- I/O 연산 증가
    - 인덱스 페이지와 데이터 페이지와 구분되있기 때문에, 데이터에 바로 접근하는 클러스터링 인덱스에 비해 I/O 빈도가 높다.
- 테이블 값이 변동되면 연산량 증가
    - 물리적 주소를 가리키고 있어, 변동 사항이 발생하면 인덱스 구조를 업데이트 해야 한다.
    - 동적인 테이블에선 클러스터링 인덱스에 비해 오버헤드가 적다.
    하지만, 논 클러스터링 인덱스를 많이 적용할 수록 불리해진다.

## 인덱스를 거는 기준

1. WHERE 조건절에 반드시 들어오는 컬럼 (중복된 값이 없을 수록 좋다.)
    1. 이를 **카디널리티가 높다**고 한다.
    예를 들어 성별은 2가지 밖에 없으니 카디널리티가 낮다고 볼 수 있다.
    반면, ID 같은 경우, 컬럼마다 고윳값을 가지니 카디널리티가 높다.
    
    전자의 경우, 성별 안에서 선형 탐색이나 추가 인덱싱을 통해 탐색해야 하지만
    후자의 경우, 인덱싱만으로 대부분의 데이터logN 로 원하는 데이터에 접근할 수 있다.
    
    요약하면 **데이터를 많이 걸러낸다 = 카디널리티가 높다** 라고 볼 수 있다.
2. 범위 조회가 자주 일어난다면 클러스터링 인덱스 적용
    1. 한번 데이터를 가져올 때 **연관된 데이터를 많이 가져올 수록 I/O 빈도가 줄어든다.**
    범위 안의 데이터들이 여러 block에 분산된다면 그만큼 I/O 작업을 수행해야 하지만
    한 block 안에 모여있다면, 1번의 I/O 요청으로 필요한 데이터를 모두 가져올 수 있다.

## 인덱싱에도 순서가 필요한가?

쿼리 상에선 순서를 섞어도 상관 없지만, **DML을 통해 인덱스 지정 시엔 순서가 필요**하다.

카디널리티가 높은 순 → 낮은 순으로 지정하는게 성능상의 이점이 있다.

복합 인덱스의 경우 쿼리 옵티마이저가 인덱스를 지정한 순서대로 쿼리 플랜을 만들기 때문이다.

하지만, 처음 지정한 인덱스가 WHERE 조건절에 없는 경우 인덱싱을 수행하지 않는다.

예를 들어, A, B, C 컬럼 순서대로 인덱스를 적용했을 때

WHERE 조건절에 A, C 를 적용하면 인덱싱이 적용되지만
B, C 를 적용하면 인덱싱을 수행하지 않는다.

이를 통해 복합 인덱스에선 쿼리 옵티마이저가 순서를 고려한단 것을 알 수 있다.

## B Tree

대표적인 인덱스 알고리즘

이진 트리와 유사하지만 다음 특징이 있다.

1. 노드당 여러 개의 키를 가질 수 있다.
2. 노드의 자식 수 = 부모의 키 개수 + 1
3. 모든 리프 노드가 동일한 depth

이렇게 전체 데이터가 N개일 때, logN 의 시간 복잡도를 가진다.
하지만, **한 노드 내에 여러 키가 있기 때문에 이 안에서도 탐색을 수행**해야 한다.
만약, 노드당 M개의 키를 가질 수 있다면 정확한 시간 복잡도는 다음과 같다.

선형 탐색의 경우 M * logN
이분 탐색의 경우 logM * logN

M이 제외되는 이유는 N에 비해 월등히 작기 때문에 무시되는것 같다.

**최소 차수 (t)**

**인덱스 노드 = 디스크 block**이라 볼 수 있다.
디스크 block의 크기와 키의 크기가 다르기 때문에
컬럼에 따라 한 block에 최대한 담을 수 있는 키 개수는 다르다.

B tree의 load factor가 0.5이기 때문에 한 노드당 t - 1개의 키를 갖도록 제한한다.
그 이상으로 가질 수 있지만, 2t 개가 되면 block 크기를 넘을 수 있어 노드를 분할한다.

차수란 말이 번역상의 문제인거 같은데, 실제 시뮬레이션 돌려보면 키를 최소 차수 미만으로 가져도 트리는 유지된다.
B Tree의 노드가 하나의 디스크 block으로 보고, 키의 크기에 따라 최대로 넣는 키 개수가 달라진다 정도만 알면 될듯 

## B+ Tree

기존 B Tree의 단점을 개선한 트리

### 범위 검색에 취약한 B Tree

B Tree에선 데이터가 노드 여기저기에 존재한다.

만약, 인접한 범위 조회시 트리를 다시 탐색해야 하는 비효율적인 부분을 B+ Tree가 보완한다.

B+Tree에선 데이터는 리프 노드에만 존재하고, 리프 노드는 연결리스트 형태로 관리된다.

즉, 트리를 순회할 필요 없이 다음 노드로만 접근하면 원하는 데이터를 찾을 수 있다.

## PK 가 없는 경우엔 어떻게 할까

위에 설명을 보면 테이블에 PK가 존재하지 않을 수 있다.

이 경우, DBMS 엔진이 자체적으로 PK를 만들어 관리한다.

하지만, 실제로 우리가 지정한 PK에 비해 성능이 많이 떨어진다.
