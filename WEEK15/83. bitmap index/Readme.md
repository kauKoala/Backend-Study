카디널리티가 `낮은`(= 중복 데이터 ⬇️) 칼럼에 유리함

비트맵(=비트)로 인덱스를 관리. 각 비트는 id값과 매칭됨

특정 상황에선 B tree에 비해 적은 공간, 연산 횟수로 인덱스를 관리할 수 있다.

오라클 docs 기준 카디널리티 수치가 1% 미만이면 큰 효과를 볼 수 있다 한다.

https://docs.oracle.com/cd/B10500_01/server.920/a96520/indexes.htm



## 어떻게 구성되나?

생성형 AI마다 답변이 달라서 공식문서까지 확인

### chatgpt 4 (Oracle, Postgre, MySQL)

![image](https://github.com/kauKoala/Backend-Study/assets/7845568/9f1e0dc5-2de2-4ed3-ba01-4eef08cab3ac)

![image](https://github.com/kauKoala/Backend-Study/assets/7845568/e38e4203-205f-4173-b754-96e8c43aa2ea)

(사진출처: https://www.geeksforgeeks.org/)

성별 컬럼(’남자’, ‘여자’, 응답 안 함’) `3`가지로 구성되면 카디널리티는 3이다.

`3`개의 비트맵 인덱스를 만들고 각 인덱스엔 `행의 개수만큼 비트 배열`을 만든다.

`1`, `2` 번째 **행만** 성별 값이 ‘`남자`’ 라면 여기에 대한 비트맵 인덱스는 0…0`11` 이고

‘`여자`’와 ‘`응답 안 함`’에 대한 비트맵 인덱스는 x…x`00`이 된다.

### Claude 2.1

얘는 왜 이렇게 알려주는지 모르겠는데 이렇게 구현할 수도 있는듯

위와 동일한 환경에서 카디널리티가 `3`이므로 길이가 `3`인 비트 배열을 만든다.

`매핑 테이블`을 만들어 ’남자’, ‘여자’, 응답 안 함’을 `특정 비트와 매칭`하게 한다.

예를 들어 ‘남자’는 `001`, ‘여자’는 `010`, ‘응답 안 함’은 `100` 이다.

## 시간 복잡도

단일 데이터 검색에서 `O(1)`의 시간 복잡도

## 불리한 상황

카디널리티가 `높을` 때 ⇒ 카디널리티 값 만큼 인덱스 비트가 생겨 공간 낭비

범위 검색 ⇒ `O(N * M)` `N`: 비트맵 길이(=행 개수) `M`: 검색 범

## 클러스터링 인덱스와 차이

물리적 정렬 → 인접한 데이터 검색에 유리

인접한 범위 조회에선 클러스터링 인덱스가 유리하다.

## 애플리케이션 관점에서..

https://www.oracle.com/technical-resources/articles/sharma-indexes.html

카디널리티 관점이 아닌 애플리케이션 관점에 대한 글

애드훅 쿼리(임시성 질의)가 자주 사용되는 상황에선 카디널리티가 100%라도 비트맵 인덱스가 빠르다.



**결론 요약**

50개의 열에서 10개 정도만 자주 접근될 때

10개의 모든 열이나 단일 열로 b-tree 인덱스를 만드는 것은 매우 어렵다.

하지만 10bit 짜리 비트맵 인덱스를 만든다면 4개, 6개 조합이라도 인덱스를 통해 조회할 수 있다.

물론 b-tree도 여러 조합에 대해 인덱스를 적용할 수 있지만 오라클 테이블은 인덱스 개수 제한이 `5`개다.

하지만 오래된 글이기 때문에 실제 상황에서 써봐야 알듯

## Reference

https://docs.oracle.com/cd/B10500_01/server.920/a96520/indexes.htm

https://postgresql.kr/blog/pg_scan_cost.html

https://www.geeksforgeeks.org/bitmap-indexing-in-dbms/

