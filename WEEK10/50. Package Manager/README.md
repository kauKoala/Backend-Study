# Package Manager



## 패키지란?

패키지는 코드, 리소스, 메타데이터 등을 포함하는 **소프트웨어의 배포 단위**

**모듈** 이나 **라이브러리**를 포함할 수 있고 **의존성 정보, 버전 정보 등 메타데이터를 포함**

- 라이브러리
  - 특정 기능을 구현하기 위해 사용할 수 있는 코드의 모음
- 모듈
  - 프로그램 내에서 재사용 가능한 단위



## 패키지 매니저란?

 소프트웨어를 설치, 업데이트, 구성 및 제거하는 과정을 자동화하는 소프트웨어 도구



## 패키지 매니저의 필요성?



### 간편한 패키지 다운로드 & 버전관리

사용자가 특정 버전의 패키지를 웹에서 찾아 프로젝트에 저장하는 방법에서 벗어나

패키지매니저에서 제공하는 형식(CLI, 파일)을 통해 특정 버전의 패키지를 설치, 업그레이드, 다운그레이드가 가능함

파일 형식으로 저장한다면 코드베이스에 해당 프로젝트 관련 패키지 버전을 공유 및 저장할 수 있음

### 의존성 관리

어떤 패키지를 동작시키기 위해 특정 패키지가 필요한 경우가 존재하는데 이를 의존성이라함

패키지가 많아질 수록 의존성이 복잡해져 모든 의존성을 찾고 효울적으로 관리하는데 한계가 있음

패키지 매니저는 자동으로 의존성을 찾아주고 관리하는걸 지원함



### 자동업데이트

명시된 버전에서 중요한 업데이트(취약점, 성능 이슈, 의존성 문제)가 발생할 경우 자동으로 업데이트, 다운그레이드를 지원함

(새로운 버전 출시에도 개발자가 명시적으로 버전을 명시하지 않아도됨)



## Software Repository?

-  소프트웨어 패키지가 저장되고 관리되는 서버 또는 웹사이트
-  패키지 매니저는 Software Repository를 통해 필요한 패키지와 업데이트를 검색하고 다운로드함
-  사용자가 직접 Software Repository에서 특정 패키지를 찾을 수도 있음
-  예시
   - **Maven Central Repository**
     - Java 생태계의 존엄,,
   - **PyPI**
   - **npm Registry**

### 패키지 매니저의 예시

- apt
  - Advanced Package Tool의 약자
  - Debian 계열의 Linux 배포판(Ubuntu, Kali Linux)에서 사용하는 패키지 관리 도구
  - 사용자는 CLI 명령으로 네트워크를 통해 패키지 저장소에 접근하여 필요한 패키지 정보를 가져옴
  - `/etc/apt/sources.list`파일과 해당 디렉토리에 있는 다른 파일들을 통해 패키지 소스(저장소)를 관리
  - `apt-get`  과 `apt`의 차이
    - `apt-get`은 스크립트, 자동화에 초점이 맞춰짐
    - `apt`는 CLI 환겨엥 초점이 맞춰짐

- npm
  - Node.js의 패키지 매니저 
  - 수많은 오픈소스 라이브러리를 개발자들이 쉽게 공유하고 관리할 수 있음
  - 현재 JS 환경 프론트엔드 개발에서 yarn과 더불어 매우 인기많음
  - `package.json`파일을 통해 프로젝트 의존성을 관리함
  - 번외
    - https://www.youtube.com/watch?v=4Syo6Qbe3oY

- pip
  - 파이썬에서 사용되는 패키지 매니저
  - PyPI(Python Package Index)에 호스팅된 수많은 패키지를 쉽게 설치할 수 있도록 해줌
  - 머신러닝, 데이터 엔지니어링을 위한 라이브러리들은 복잡한 의존성, 네이티브 바이너리(하드웨어,시스템에 따른 종속성)에 따라 패키지 관리에 있어
    복잡한 요구사항이 존재하므로 이를 위해 `conda`도 많이 사용됨

## Maven vs Gradle

![image](https://github.com/sj7699/Backend-Study/assets/26706925/05d7c858-a30a-41f9-bf9d-ab42c5294975)


### 스크립트

Maven은 XML 기반으로 빌드, 의존성을 관리한다.

Gradle은 Groovy언어를 바탕으로 빌드 스크립트를 구성할 수 있다. Groovy언어를 통해 if, for과 같은 프로그래밍 로직을 적용할 수 있어 복잡한 빌드 요구사항 구현 가능



### 전이적 의존성

전이적 의존성은 한 의존성이 자동으로 다른 의존성을 포함해버리는 경우를 말한다.

의존성의 의존성과 같은 복잡한 관계를 자동으로 관리해주는 개발자에게 고마운 개념

Maven과 Gradle은 전이적 의존성에 대해 다른 방법을 사용한다.

#### Maven

Maven은 `가장 가까운 의존성 원칙`을 사용한다. 

프로젝트에 가장 가까운 (의존성 선언인 pom.xml에 가장 가까운) 의존성을 채택한다. 

예시) pom.xml에서 라이브러리 A 1.0 버전을 명시적으로 의존하고 라이브러리 B를 의존하고 있다.

이 상황에서 라이브러리 B가 라이브러리 A의 2.0버전을 의존했을때 Maven은 라이브러리 A 1.0 버전을 선택한다.

의존성 트리(위와 같이 서로 의존하는 관계를 트리로 표현한것)에서 **가장 가까운** 라이브러리 A 버전이 1.0이기 때문이다.



#### Gradle

Gradle은 `가장 새로운 의존성 원칙`을 사용한다.

전이적 의존성 가운데 중복되는 라이브러리들의 여러 버전 중 가장 최신 버전을 우선적으로 선택한다.

Gradle은 **resolutionStrategy**를 사용해 위 원칙을 유연하게 개발자가 변경할 수 있다.

또한 충돌하는 버전이나 취약점이 발견된 라이브러리를 제외하기 위해 **특정 의존성을 전이적 의존성에도 포함하지 않을 수 있다.**



### 빌드 성능

Gradle은 왜 빠른가?

- Gradle은 이전 빌드와 비교하여 변경된 파일만 재컴파일/처리하기에 빌드 시간을 줄임
- 이전에 실행된 빌드의 출력을 캐싱함
- 빌드 스크립트에 프로그래밍 로직을 통해 최적화 요소를 넣을 수 있음


![image](https://github.com/sj7699/Backend-Study/assets/26706925/074f8019-379c-4db2-8b5d-3d75aaf4c6b3)


그냥 Gradle 쓰는게 나은것 같다..



## 자료 출처

https://aahc.tistory.com/14

https://gradle.org/maven-vs-gradle/
